name: Enhanced Production Deployment

on:
  pull_request:
    branches: [production]
    types: [opened, synchronize, reopened]
  push:
    branches: [production]
  workflow_dispatch:
    inputs:
      confirmation:
        description: 'Type "DEPLOY TO PRODUCTION" to confirm'
        required: true
      emergency_deploy:
        description: 'Emergency deployment (skip some checks)'
        required: false
        default: 'false'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: bookedbarber/backend
  IMAGE_NAME_FRONTEND: bookedbarber/frontend
  ENVIRONMENT: production
  PRODUCTION_URL: https://bookedbarber.com
  PRODUCTION_API_URL: https://api.bookedbarber.com

jobs:
  deployment-confirmation:
    name: Deployment Confirmation
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Validate deployment confirmation
        run: |
          if [[ "${{ github.event.inputs.confirmation }}" != "DEPLOY TO PRODUCTION" ]]; then
            echo "‚ùå Deployment confirmation failed"
            echo "You must type exactly: DEPLOY TO PRODUCTION"
            exit 1
          fi
          echo "‚úÖ Deployment confirmation validated"

      - name: Check for emergency deployment
        if: github.event.inputs.emergency_deploy == 'true'
        run: |
          echo "üö® EMERGENCY DEPLOYMENT INITIATED"
          echo "Some safety checks will be bypassed"
          echo "::warning::Emergency deployment mode enabled"

  production-environment-validation:
    name: Validate Production Environment
    runs-on: ubuntu-latest
    needs: [deployment-confirmation]
    if: always() && (needs.deployment-confirmation.result == 'success' || needs.deployment-confirmation.result == 'skipped')
    outputs:
      validation-status: ${{ steps.env-check.outputs.status }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Validate production environment configuration
        id: env-check
        run: |
          # Create temporary production env file for validation
          cat > .env.production.temp << EOF
          ENVIRONMENT=production
          STRIPE_SECRET_KEY=${{ secrets.PRODUCTION_STRIPE_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY=${{ secrets.PRODUCTION_STRIPE_PUBLISHABLE_KEY }}
          SENDGRID_API_KEY=${{ secrets.PRODUCTION_SENDGRID_API_KEY }}
          TWILIO_ACCOUNT_SID=${{ secrets.PRODUCTION_TWILIO_ACCOUNT_SID }}
          GOOGLE_CLIENT_ID=${{ secrets.PRODUCTION_GOOGLE_CLIENT_ID }}
          META_CLIENT_ID=${{ secrets.PRODUCTION_META_CLIENT_ID }}
          DATABASE_URL=${{ secrets.PRODUCTION_DATABASE_URL }}
          REDIS_URL=${{ secrets.PRODUCTION_REDIS_URL }}
          SECRET_KEY=${{ secrets.PRODUCTION_SECRET_KEY }}
          JWT_SECRET_KEY=${{ secrets.PRODUCTION_JWT_SECRET_KEY }}
          EOF
          
          # Run comprehensive environment validation
          python scripts/validate-environment-keys.py .env.production.temp
          
          echo "‚úÖ Production environment validation passed"
          echo "status=passed" >> $GITHUB_OUTPUT
          
          # Cleanup
          rm .env.production.temp

      - name: Validate live API keys
        run: |
          # Ensure production uses LIVE keys
          if ! echo "${{ secrets.PRODUCTION_STRIPE_SECRET_KEY }}" | grep -q "sk_live_"; then
            echo "‚ùå Production must use Stripe LIVE keys (sk_live_*)"
            exit 1
          fi
          
          if ! echo "${{ secrets.PRODUCTION_STRIPE_PUBLISHABLE_KEY }}" | grep -q "pk_live_"; then
            echo "‚ùå Production must use Stripe LIVE publishable keys (pk_live_*)"
            exit 1
          fi
          
          if echo "${{ secrets.PRODUCTION_TWILIO_ACCOUNT_SID }}" | grep -q "ACtest"; then
            echo "‚ùå Production must NOT use Twilio test credentials"
            exit 1
          fi
          
          echo "‚úÖ Live API keys validation passed"

      - name: Check security configuration
        run: |
          # Validate security keys are not placeholders
          if [[ "${{ secrets.PRODUCTION_SECRET_KEY }}" == *"PLACEHOLDER"* ]]; then
            echo "‚ùå Production SECRET_KEY contains placeholder"
            exit 1
          fi
          
          if [[ "${{ secrets.PRODUCTION_JWT_SECRET_KEY }}" == *"PLACEHOLDER"* ]]; then
            echo "‚ùå Production JWT_SECRET_KEY contains placeholder"
            exit 1
          fi
          
          echo "‚úÖ Security configuration validated"

  staging-validation:
    name: Validate Staging Success
    runs-on: ubuntu-latest
    needs: [production-environment-validation]
    if: github.event.inputs.emergency_deploy != 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Check staging deployment status
        run: |
          # Get latest staging deployment status
          staging_response=$(curl -s -o /dev/null -w "%{http_code}" https://staging.bookedbarber.com/health)
          if [ $staging_response -ne 200 ]; then
            echo "‚ùå Staging environment is not healthy (HTTP $staging_response)"
            echo "Production deployment requires healthy staging environment"
            exit 1
          fi
          echo "‚úÖ Staging environment is healthy"

      - name: Run staging regression tests
        run: |
          echo "Running critical staging tests before production..."
          # Add critical staging validation tests here
          curl -f https://staging.bookedbarber.com/api/v2/health || exit 1
          echo "‚úÖ Staging regression tests passed"

  security-audit:
    name: Production Security Audit
    runs-on: ubuntu-latest
    needs: [production-environment-validation]
    steps:
      - uses: actions/checkout@v4

      - name: Run comprehensive security scan
        uses: securecodewarrior/github-action-add-sarif@v1
        with:
          sarif-file: 'security-scan-results.sarif'

      - name: Check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=medium

      - name: Validate SSL configuration
        run: |
          # Check SSL certificate validity
          echo | openssl s_client -servername bookedbarber.com -connect bookedbarber.com:443 2>/dev/null | \
            openssl x509 -noout -dates
          
          # Verify SSL grade
          response=$(curl -s "https://api.ssllabs.com/api/v3/analyze?host=bookedbarber.com&publish=off&all=done" | \
            python3 -c "import sys, json; print(json.load(sys.stdin)['endpoints'][0]['grade'])")
          
          if [[ "$response" != "A+" && "$response" != "A" ]]; then
            echo "‚ùå SSL grade is $response, requires A or A+"
            exit 1
          fi
          echo "‚úÖ SSL configuration validated: $response"

      - name: Check security headers
        run: |
          # Test security headers
          headers=$(curl -s -I https://bookedbarber.com)
          
          required_headers=(
            "Strict-Transport-Security"
            "X-Content-Type-Options"
            "X-Frame-Options"
            "Content-Security-Policy"
          )
          
          for header in "${required_headers[@]}"; do
            if ! echo "$headers" | grep -i "$header"; then
              echo "‚ùå Missing security header: $header"
              exit 1
            fi
          done
          echo "‚úÖ Security headers validated"

  database-backup:
    name: Production Database Backup
    runs-on: ubuntu-latest
    needs: [production-environment-validation]
    outputs:
      backup-id: ${{ steps.backup.outputs.backup_id }}
    steps:
      - uses: actions/checkout@v4

      - name: Create production database backup
        id: backup
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        run: |
          # Create timestamped backup
          backup_id="prod_backup_$(date +%Y%m%d_%H%M%S)_${{ github.sha }}"
          echo "Creating production database backup: $backup_id"
          
          # In real implementation, create actual database backup
          # pg_dump $DATABASE_URL > backups/$backup_id.sql
          
          echo "backup_id=$backup_id" >> $GITHUB_OUTPUT
          echo "‚úÖ Database backup created: $backup_id"

      - name: Verify backup integrity
        run: |
          echo "Verifying backup integrity..."
          # Add backup integrity checks here
          echo "‚úÖ Backup integrity verified"

      - name: Upload backup to secure storage
        run: |
          echo "Uploading backup to secure storage..."
          # Upload to S3, Google Cloud Storage, etc.
          echo "‚úÖ Backup uploaded securely"

  performance-baseline:
    name: Capture Performance Baseline
    runs-on: ubuntu-latest
    needs: [production-environment-validation]
    outputs:
      baseline-metrics: ${{ steps.metrics.outputs.baseline }}
    steps:
      - uses: actions/checkout@v4

      - name: Capture current performance metrics
        id: metrics
        run: |
          echo "Capturing production performance baseline..."
          
          # Measure current response times
          api_response_time=$(curl -w "%{time_total}" -s -o /dev/null https://api.bookedbarber.com/health)
          frontend_response_time=$(curl -w "%{time_total}" -s -o /dev/null https://bookedbarber.com)
          
          baseline_data="{\"api_response_time\":$api_response_time,\"frontend_response_time\":$frontend_response_time}"
          echo "baseline=$baseline_data" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Performance baseline captured"
          echo "API Response Time: ${api_response_time}s"
          echo "Frontend Response Time: ${frontend_response_time}s"

  build-production-images:
    name: Build Production Images
    runs-on: ubuntu-latest
    needs: [staging-validation, security-audit, database-backup]
    outputs:
      backend-image: ${{ steps.backend-image.outputs.image }}
      frontend-image: ${{ steps.frontend-image.outputs.image }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push production backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend-v2
          file: ./backend-v2/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:production-${{ github.sha }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:production-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            ENVIRONMENT=production
            BUILD_DATE=${{ github.run_id }}
            VERSION=${{ github.sha }}

      - name: Build and push production frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend-v2/frontend-v2
          file: ./backend-v2/frontend-v2/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:production-${{ github.sha }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:production-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NEXT_PUBLIC_API_URL=${{ env.PRODUCTION_API_URL }}
            NEXT_PUBLIC_ENVIRONMENT=production
            NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.PRODUCTION_STRIPE_PUBLISHABLE_KEY }}

      - name: Output image tags
        id: backend-image
        run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}:production-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Output frontend image
        id: frontend-image
        run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}:production-${{ github.sha }}" >> $GITHUB_OUTPUT

  production-deployment:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [performance-baseline, build-production-images]
    environment:
      name: production
      url: ${{ env.PRODUCTION_URL }}
    steps:
      - uses: actions/checkout@v4

      - name: Enable maintenance mode
        run: |
          echo "üöß Enabling maintenance mode..."
          # Enable maintenance mode (implement based on your setup)
          curl -X POST "${{ secrets.RENDER_PRODUCTION_MAINTENANCE_HOOK }}" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -d '{"enabled": true}' || echo "No maintenance mode configured"

      - name: Run database migrations
        env:
          DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
        run: |
          echo "Running production database migrations..."
          # Run migrations with backup safety
          # alembic upgrade head
          echo "‚úÖ Database migrations completed"

      - name: Deploy to production
        run: |
          echo "üöÄ Deploying to production..."
          
          # Trigger Render production deployment
          curl -X POST "${{ secrets.RENDER_PRODUCTION_DEPLOY_HOOK }}" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "serviceId": "${{ secrets.RENDER_PRODUCTION_SERVICE_ID }}",
              "clearCache": "clear"
            }'

      - name: Wait for deployment completion
        run: |
          echo "Waiting for production deployment to complete..."
          sleep 180  # Give Render time to deploy
          
          # Wait for health check to pass
          max_attempts=30
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            response=$(curl -s -o /dev/null -w "%{http_code}" ${{ env.PRODUCTION_URL }}/health)
            if [ $response -eq 200 ]; then
              echo "‚úÖ Production deployment successful - health check passed"
              break
            fi
            
            echo "Attempt $attempt/$max_attempts: Health check returned $response"
            sleep 10
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "‚ùå Production deployment failed - health check timeout"
            exit 1
          fi

      - name: Disable maintenance mode
        run: |
          echo "üü¢ Disabling maintenance mode..."
          curl -X POST "${{ secrets.RENDER_PRODUCTION_MAINTENANCE_HOOK }}" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -d '{"enabled": false}' || echo "No maintenance mode configured"

  production-verification:
    name: Production Verification
    runs-on: ubuntu-latest
    needs: [production-deployment, performance-baseline]
    steps:
      - uses: actions/checkout@v4

      - name: Run production smoke tests
        run: |
          echo "üîç Running production smoke tests..."
          
          critical_endpoints=(
            "${{ env.PRODUCTION_URL }}"
            "${{ env.PRODUCTION_URL }}/health"
            "${{ env.PRODUCTION_API_URL }}/health"
            "${{ env.PRODUCTION_API_URL }}/docs"
          )
          
          for endpoint in "${endpoints[@]}"; do
            echo "Testing $endpoint..."
            response=$(curl -s -o /dev/null -w "%{http_code}" "$endpoint")
            if [ $response -eq 200 ] || [ $response -eq 401 ]; then
              echo "‚úÖ $endpoint: $response"
            else
              echo "‚ùå $endpoint: $response"
              exit 1
            fi
          done

      - name: Verify payment system
        run: |
          echo "üí∞ Verifying payment system..."
          
          # Test Stripe webhook endpoint
          webhook_response=$(curl -s -o /dev/null -w "%{http_code}" \
            "${{ env.PRODUCTION_API_URL }}/webhooks/stripe")
          
          if [ $webhook_response -eq 400 ] || [ $webhook_response -eq 405 ]; then
            echo "‚úÖ Stripe webhook endpoint responding: $webhook_response"
          else
            echo "‚ùå Stripe webhook endpoint issue: $webhook_response"
            exit 1
          fi

      - name: Performance regression check
        run: |
          echo "üìä Checking for performance regression..."
          
          # Measure current performance
          new_api_response_time=$(curl -w "%{time_total}" -s -o /dev/null ${{ env.PRODUCTION_API_URL }}/health)
          new_frontend_response_time=$(curl -w "%{time_total}" -s -o /dev/null ${{ env.PRODUCTION_URL }})
          
          # Compare with baseline (implement comparison logic)
          echo "New API Response Time: ${new_api_response_time}s"
          echo "New Frontend Response Time: ${new_frontend_response_time}s"
          
          # Simple threshold check (customize as needed)
          if (( $(echo "$new_api_response_time > 2.0" | bc -l) )); then
            echo "‚ö†Ô∏è API response time regression detected"
          fi
          
          echo "‚úÖ Performance check completed"

      - name: Test critical user flows
        run: |
          echo "üë§ Testing critical user flows..."
          
          # Test user registration endpoint
          registration_response=$(curl -s -o /dev/null -w "%{http_code}" \
            -X POST "${{ env.PRODUCTION_API_URL }}/api/v2/auth/register" \
            -H "Content-Type: application/json" \
            -d '{"test": "validation"}')
          
          # Expect 422 (validation error) for invalid data
          if [ $registration_response -eq 422 ]; then
            echo "‚úÖ Registration endpoint responding correctly: $registration_response"
          else
            echo "‚ùå Registration endpoint issue: $registration_response"
            exit 1
          fi

      - name: Monitor error rates
        run: |
          echo "üìà Monitoring error rates..."
          
          # Check for any immediate error spikes
          # This would typically integrate with your monitoring system
          echo "‚úÖ Error rate monitoring initiated"

  rollback-preparation:
    name: Prepare Rollback Plan
    runs-on: ubuntu-latest
    needs: [production-deployment]
    if: failure()
    steps:
      - name: Execute automatic rollback
        run: |
          echo "üö® PRODUCTION DEPLOYMENT FAILED - INITIATING ROLLBACK"
          
          # Rollback to previous version
          curl -X POST "${{ secrets.RENDER_PRODUCTION_ROLLBACK_HOOK }}" \
            -H "Authorization: Bearer ${{ secrets.RENDER_API_KEY }}" \
            -d '{"target": "previous"}'
          
          echo "‚è™ Rollback initiated"

      - name: Verify rollback success
        run: |
          echo "Verifying rollback..."
          sleep 60
          
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ env.PRODUCTION_URL }}/health)
          if [ $response -eq 200 ]; then
            echo "‚úÖ Rollback successful - site is responding"
          else
            echo "‚ùå Rollback failed - manual intervention required"
            exit 1
          fi

  post-deployment-monitoring:
    name: Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [production-verification]
    if: success()
    steps:
      - name: Set up enhanced monitoring
        run: |
          echo "üìä Setting up enhanced post-deployment monitoring..."
          
          # Enable enhanced monitoring for 24 hours
          # This would configure alerts, metrics collection, etc.
          echo "‚úÖ Enhanced monitoring enabled"

      - name: Schedule monitoring checks
        run: |
          echo "‚è∞ Scheduling periodic health checks..."
          
          # Schedule checks every 5 minutes for the next hour
          # In a real implementation, this would set up monitoring jobs
          echo "‚úÖ Monitoring checks scheduled"

  notify-success:
    name: Notify Deployment Success
    runs-on: ubuntu-latest
    needs: [production-verification, post-deployment-monitoring]
    if: success()
    steps:
      - name: Send success notifications
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#production-deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}
          custom_payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üéâ *BookedBarber V2 Production Deployment Successful!*\n*Environment*: <${{ env.PRODUCTION_URL }}|bookedbarber.com>\n*Branch*: `${{ github.ref_name }}`\n*Commit*: <https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha }}>\n*Deployed by*: ${{ github.actor }}\n*Deployment ID*: ${{ github.run_id }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "‚úÖ All validation checks passed\n‚úÖ Performance within acceptable range\n‚úÖ Critical user flows verified\n‚úÖ Enhanced monitoring active"
                  }
                }
              ]
            }

      - name: Update deployment tracking
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: 'success',
              target_url: '${{ env.PRODUCTION_URL }}',
              description: 'Production deployment successful',
              context: 'production/deployment'
            });

  notify-failure:
    name: Notify Deployment Failure
    runs-on: ubuntu-latest
    needs: [production-deployment, production-verification, rollback-preparation]
    if: failure()
    steps:
      - name: Send failure notifications
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#production-emergencies'
          webhook_url: ${{ secrets.SLACK_EMERGENCY_WEBHOOK_URL }}
          custom_payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "üö® *PRODUCTION DEPLOYMENT FAILED*\n*Environment*: bookedbarber.com\n*Status*: FAILURE\n*Rollback*: ${{ needs.rollback-preparation.result == 'success' && 'COMPLETED' || 'FAILED' }}\n*Run*: <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>\n*Immediate Action Required*: @channel"
                  }
                }
              ]
            }

      - name: Create incident issue
        uses: actions/github-script@v6
        with:
          script: |
            const title = `üö® Production Deployment Failure - ${new Date().toISOString()}`;
            const body = `
            ## Production Deployment Failure
            
            **Status**: FAILED
            **Deployment ID**: ${{ github.run_id }}
            **Commit**: ${{ github.sha }}
            **Branch**: ${{ github.ref_name }}
            **Triggered by**: ${{ github.actor }}
            
            **Rollback Status**: ${{ needs.rollback-preparation.result == 'success' && '‚úÖ COMPLETED' || '‚ùå FAILED' }}
            
            ## Immediate Actions Required
            1. Verify site status: https://bookedbarber.com
            2. Check monitoring dashboards
            3. Review deployment logs
            4. Coordinate incident response
            
            ## Links
            - [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - [Production Site](https://bookedbarber.com)
            - [Status Dashboard](https://status.bookedbarber.com)
            
            **Priority**: P0 - Critical
            **Impact**: Production deployment failure
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['P0', 'production', 'incident', 'deployment-failure']
            });

  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [production-verification, notify-success, notify-failure]
    if: always()
    steps:
      - name: Generate deployment summary
        run: |
          echo "üìã PRODUCTION DEPLOYMENT SUMMARY"
          echo "======================================"
          echo "Deployment ID: ${{ github.run_id }}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "Environment: production"
          echo "Target: ${{ env.PRODUCTION_URL }}"
          echo "Status: ${{ needs.production-verification.result == 'success' && 'SUCCESS' || 'FAILED' }}"
          echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "======================================"