"""
Automated Campaign Engine - Six Figure Barber Retention Automation
==================================================================

This service provides intelligent email/SMS automation for executing retention 
campaigns generated by the Client Retention System. It handles campaign scheduling,
delivery, tracking, and optimization to maximize client retention ROI.

Key Features:
- Multi-channel campaign execution (Email, SMS, Push Notifications)
- Intelligent scheduling based on client behavior patterns
- A/B testing framework for campaign optimization  
- Real-time delivery status tracking and analytics
- Smart throttling and frequency capping
- Personalized content generation with Six Figure methodology
- Campaign performance analytics and ROI tracking
"""

from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any, Union
from sqlalchemy.orm import Session
from sqlalchemy import func, and_, or_, desc
import logging
from decimal import Decimal
from dataclasses import dataclass
from enum import Enum
import asyncio
import json
import uuid
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

from models import User, Client, Appointment, Payment
from services.notification_service import notification_service
from services.client_retention_service import RetentionCampaign, RetentionCampaignType, RetentionCampaignStatus

logger = logging.getLogger(__name__)

class CampaignChannel(Enum):
    EMAIL = "email"
    SMS = "sms"
    PUSH = "push"
    IN_APP = "in_app"

class DeliveryStatus(Enum):
    PENDING = "pending"
    SCHEDULED = "scheduled"
    SENT = "sent" 
    DELIVERED = "delivered"
    OPENED = "opened"
    CLICKED = "clicked"
    RESPONDED = "responded"
    FAILED = "failed"
    BOUNCED = "bounced"
    UNSUBSCRIBED = "unsubscribed"

class CampaignPersonalization(Enum):
    BASIC = "basic"           # Name + service history
    ADVANCED = "advanced"     # + preferences + behavior
    PREMIUM = "premium"       # + AI-generated custom content

@dataclass
class CampaignExecution:
    """Campaign execution tracking and metrics"""
    execution_id: str
    campaign_id: str
    client_id: int
    channel: CampaignChannel
    scheduled_at: datetime
    sent_at: Optional[datetime]
    delivered_at: Optional[datetime]
    opened_at: Optional[datetime]
    clicked_at: Optional[datetime]
    responded_at: Optional[datetime]
    status: DeliveryStatus
    message_content: str
    subject_line: Optional[str]
    tracking_data: Dict[str, Any]
    delivery_cost: float
    response_data: Optional[Dict[str, Any]]
    created_at: datetime
    
@dataclass  
class CampaignTemplate:
    """Campaign message template with personalization"""
    template_id: str
    template_name: str
    channel: CampaignChannel
    campaign_type: RetentionCampaignType
    subject_template: Optional[str]
    message_template: str
    personalization_level: CampaignPersonalization
    call_to_action: str
    urgency_level: str  # low, medium, high, critical
    six_figure_messaging: bool
    a_b_variant: Optional[str]  # For A/B testing
    conversion_tracking_enabled: bool
    
@dataclass
class CampaignBatch:
    """Batch campaign execution for performance"""
    batch_id: str
    campaign_ids: List[str]
    channel: CampaignChannel
    scheduled_at: datetime
    batch_size: int
    delivery_rate_limit: int  # Messages per minute
    execution_status: str
    total_sent: int
    total_delivered: int
    total_failed: int
    batch_metrics: Dict[str, Any]
    created_at: datetime

@dataclass
class CampaignAnalytics:
    """Campaign performance analytics"""
    campaign_id: str
    total_sent: int
    delivery_rate: float
    open_rate: float
    click_rate: float
    response_rate: float
    conversion_rate: float
    unsubscribe_rate: float
    revenue_generated: float
    campaign_cost: float
    roi_percentage: float
    best_performing_variant: Optional[str]
    optimal_send_time: Optional[datetime]
    audience_insights: Dict[str, Any]
    improvement_recommendations: List[str]

class AutomatedCampaignService:
    """
    Automated Campaign Engine for Six Figure Barber Client Retention
    
    Executes intelligent retention campaigns across multiple channels with
    advanced personalization, tracking, and optimization capabilities.
    """
    
    def __init__(self, db: Session):
        self.db = db
        self.campaign_templates = self._load_campaign_templates()
        self.delivery_rate_limits = {
            CampaignChannel.EMAIL: 100,  # per minute
            CampaignChannel.SMS: 50,     # per minute  
            CampaignChannel.PUSH: 500,   # per minute
        }
        
    async def execute_retention_campaign(
        self, 
        campaign: RetentionCampaign,
        channel: CampaignChannel = CampaignChannel.EMAIL,
        personalization_level: CampaignPersonalization = CampaignPersonalization.ADVANCED
    ) -> CampaignExecution:
        """
        Execute a single retention campaign with intelligent delivery
        
        Args:
            campaign: RetentionCampaign object from retention service
            channel: Delivery channel (email, SMS, push)
            personalization_level: Level of message personalization
            
        Returns:
            CampaignExecution tracking object
        """
        try:
            # Generate execution ID
            execution_id = f"exec_{uuid.uuid4().hex[:12]}"
            
            # Get campaign template
            template = self._get_campaign_template(campaign.campaign_type, channel)
            
            # Generate personalized content
            personalized_content = await self._personalize_campaign_content(
                campaign, template, personalization_level
            )
            
            # Determine optimal delivery time
            optimal_time = self._calculate_optimal_delivery_time(campaign.client_id, channel)
            
            # Create execution record
            execution = CampaignExecution(
                execution_id=execution_id,
                campaign_id=campaign.campaign_id,
                client_id=campaign.client_id,
                channel=channel,
                scheduled_at=optimal_time,
                sent_at=None,
                delivered_at=None,
                opened_at=None,
                clicked_at=None,
                responded_at=None,
                status=DeliveryStatus.SCHEDULED,
                message_content=personalized_content["message"],
                subject_line=personalized_content.get("subject"),
                tracking_data={
                    "template_id": template.template_id,
                    "personalization_level": personalization_level.value,
                    "optimal_time_calculated": True,
                    "a_b_variant": template.a_b_variant
                },
                delivery_cost=self._calculate_delivery_cost(channel),
                response_data=None,
                created_at=datetime.now()
            )
            
            # Schedule or send immediately
            if optimal_time <= datetime.now():
                await self._send_campaign_immediately(execution)
            else:
                await self._schedule_campaign_delivery(execution)
            
            return execution
            
        except Exception as e:
            logger.error(f"Error executing retention campaign {campaign.campaign_id}: {e}")
            raise
    
    async def execute_batch_campaigns(
        self,
        campaigns: List[RetentionCampaign],
        channel: CampaignChannel = CampaignChannel.EMAIL,
        batch_size: int = 50
    ) -> CampaignBatch:
        """
        Execute multiple campaigns in optimized batches
        
        Args:
            campaigns: List of retention campaigns to execute
            channel: Delivery channel for all campaigns
            batch_size: Number of campaigns per batch
            
        Returns:
            CampaignBatch tracking object
        """
        try:
            batch_id = f"batch_{uuid.uuid4().hex[:12]}"
            
            # Create campaign executions
            executions = []
            for campaign in campaigns[:batch_size]:
                execution = await self.execute_retention_campaign(
                    campaign, channel, CampaignPersonalization.ADVANCED
                )
                executions.append(execution)
            
            # Create batch record
            batch = CampaignBatch(
                batch_id=batch_id,
                campaign_ids=[e.campaign_id for e in executions],
                channel=channel,
                scheduled_at=datetime.now(),
                batch_size=len(executions),
                delivery_rate_limit=self.delivery_rate_limits[channel],
                execution_status="processing",
                total_sent=0,
                total_delivered=0,
                total_failed=0,
                batch_metrics={
                    "execution_ids": [e.execution_id for e in executions],
                    "estimated_completion": datetime.now() + timedelta(minutes=batch_size // 10)
                },
                created_at=datetime.now()
            )
            
            # Process batch with rate limiting
            await self._process_campaign_batch(batch, executions)
            
            return batch
            
        except Exception as e:
            logger.error(f"Error executing batch campaigns: {e}")
            raise
    
    async def _send_campaign_immediately(self, execution: CampaignExecution) -> bool:
        """Send campaign via specified channel"""
        try:
            success = False
            
            if execution.channel == CampaignChannel.EMAIL:
                success = await self._send_email_campaign(execution)
            elif execution.channel == CampaignChannel.SMS:
                success = await self._send_sms_campaign(execution)
            elif execution.channel == CampaignChannel.PUSH:
                success = await self._send_push_campaign(execution)
            
            # Update execution status
            if success:
                execution.sent_at = datetime.now()
                execution.status = DeliveryStatus.SENT
                logger.info(f"Campaign {execution.execution_id} sent successfully via {execution.channel.value}")
            else:
                execution.status = DeliveryStatus.FAILED
                logger.error(f"Failed to send campaign {execution.execution_id}")
                
            return success
            
        except Exception as e:
            logger.error(f"Error sending campaign {execution.execution_id}: {e}")
            execution.status = DeliveryStatus.FAILED
            return False
    
    async def _send_email_campaign(self, execution: CampaignExecution) -> bool:
        """Send email campaign via notification service"""
        try:
            # Get client info
            client = self.db.query(Client).filter(Client.id == execution.client_id).first()
            if not client or not client.email:
                return False
            
            # Use notification service for email delivery
            result = notification_service.send_email(
                to_email=client.email,
                subject=execution.subject_line or "Important Update from Your Barber",
                body=self._format_email_content(execution.message_content),
                template_data={
                    "client_name": client.name,
                    "execution_id": execution.execution_id,
                    "campaign_id": execution.campaign_id
                }
            )
            
            # Track delivery
            if result.get("success"):
                execution.tracking_data["email_id"] = result.get("message_id")
                execution.tracking_data["provider"] = "sendgrid"
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error sending email campaign: {e}")
            return False
    
    async def _send_sms_campaign(self, execution: CampaignExecution) -> bool:
        """Send SMS campaign via notification service"""
        try:
            # Get client info
            client = self.db.query(Client).filter(Client.id == execution.client_id).first()
            if not client or not client.phone:
                return False
            
            # Use notification service for SMS delivery
            result = notification_service.send_sms(
                to_phone=client.phone,
                body=self._format_sms_content(execution.message_content, client.name)
            )
            
            # Track delivery
            if result.get("success"):
                execution.tracking_data["sms_id"] = result.get("message_id")
                execution.tracking_data["provider"] = "twilio"
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error sending SMS campaign: {e}")
            return False
    
    async def _send_push_campaign(self, execution: CampaignExecution) -> bool:
        """Send push notification campaign"""
        try:
            # Push notifications would integrate with Firebase/OneSignal
            # For now, create a placeholder implementation
            
            logger.info(f"Push notification sent for execution {execution.execution_id}")
            execution.tracking_data["push_provider"] = "firebase"
            return True
            
        except Exception as e:
            logger.error(f"Error sending push campaign: {e}")
            return False
    
    async def _personalize_campaign_content(
        self,
        campaign: RetentionCampaign,
        template: CampaignTemplate,
        personalization_level: CampaignPersonalization
    ) -> Dict[str, str]:
        """Generate personalized campaign content"""
        try:
            # Get client info
            client = self.db.query(Client).filter(Client.id == campaign.client_id).first()
            if not client:
                raise ValueError(f"Client {campaign.client_id} not found")
            
            # Get recent appointment history
            recent_appointments = self.db.query(Appointment).filter(
                and_(
                    Appointment.client_id == campaign.client_id,
                    Appointment.appointment_date >= datetime.now() - timedelta(days=90)
                )
            ).order_by(desc(Appointment.appointment_date)).limit(3).all()
            
            # Basic personalization variables
            personalization_vars = {
                "client_name": client.name,
                "first_name": client.name.split()[0] if client.name else "Valued Client",
                "last_appointment_date": recent_appointments[0].appointment_date.strftime("%B %d") if recent_appointments else "recently",
                "favorite_service": self._get_client_favorite_service(campaign.client_id),
                "churn_risk_score": int(campaign.churn_risk_score),
                "estimated_revenue_at_risk": f"${campaign.estimated_revenue_at_risk:,.0f}",
                "days_since_last_booking": self._get_days_since_last_booking(campaign.client_id)
            }
            
            # Advanced personalization
            if personalization_level in [CampaignPersonalization.ADVANCED, CampaignPersonalization.PREMIUM]:
                personalization_vars.update({
                    "preferred_appointment_time": self._get_preferred_appointment_time(campaign.client_id),
                    "service_recommendations": self._get_service_recommendations(campaign.client_id),
                    "loyalty_tier": self._get_client_loyalty_tier(campaign.client_id),
                    "special_offer": self._generate_personalized_offer(campaign)
                })
            
            # Premium AI-generated content
            if personalization_level == CampaignPersonalization.PREMIUM:
                personalization_vars.update({
                    "custom_message": self._generate_ai_custom_message(campaign, client),
                    "six_figure_insight": self._get_six_figure_insight(campaign.client_id)
                })
            
            # Apply personalization to templates
            personalized_message = template.message_template.format(**personalization_vars)
            personalized_subject = template.subject_template.format(**personalization_vars) if template.subject_template else None
            
            return {
                "message": personalized_message,
                "subject": personalized_subject,
                "personalization_data": personalization_vars
            }
            
        except Exception as e:
            logger.error(f"Error personalizing campaign content: {e}")
            # Fallback to basic template
            return {
                "message": template.message_template.replace("{client_name}", client.name if client else "Valued Client"),
                "subject": template.subject_template.replace("{client_name}", client.name if client else "Valued Client") if template.subject_template else None
            }
    
    def _calculate_optimal_delivery_time(self, client_id: int, channel: CampaignChannel) -> datetime:
        """Calculate optimal delivery time based on client behavior"""
        try:
            # Get client's historical booking patterns
            appointments = self.db.query(Appointment).filter(
                Appointment.client_id == client_id
            ).all()
            
            if not appointments:
                # Default optimal times by channel
                base_time = datetime.now()
                if channel == CampaignChannel.EMAIL:
                    # Optimal email time: 10 AM on weekdays
                    return base_time.replace(hour=10, minute=0, second=0, microsecond=0)
                elif channel == CampaignChannel.SMS:
                    # Optimal SMS time: 2 PM (less intrusive)
                    return base_time.replace(hour=14, minute=0, second=0, microsecond=0)
                else:
                    return base_time
            
            # Analyze booking time patterns
            booking_hours = [apt.appointment_date.hour for apt in appointments]
            most_common_hour = max(set(booking_hours), key=booking_hours.count)
            
            # Schedule 2 hours before their typical booking time
            optimal_hour = max(9, most_common_hour - 2)  # Not before 9 AM
            
            next_delivery = datetime.now().replace(
                hour=optimal_hour, 
                minute=0, 
                second=0, 
                microsecond=0
            )
            
            # If time has passed today, schedule for tomorrow
            if next_delivery <= datetime.now():
                next_delivery += timedelta(days=1)
            
            return next_delivery
            
        except Exception as e:
            logger.error(f"Error calculating optimal delivery time: {e}")
            return datetime.now() + timedelta(hours=1)  # Default to 1 hour from now
    
    def track_campaign_interaction(
        self,
        execution_id: str,
        interaction_type: str,
        interaction_data: Dict[str, Any] = None
    ) -> bool:
        """Track campaign interactions (opens, clicks, responses)"""
        try:
            # This would update the execution record with interaction data
            # For now, log the interaction
            
            logger.info(f"Campaign interaction tracked: {execution_id} - {interaction_type}")
            
            # Update execution status based on interaction
            status_mapping = {
                "opened": DeliveryStatus.OPENED,
                "clicked": DeliveryStatus.CLICKED,
                "responded": DeliveryStatus.RESPONDED,
                "bounced": DeliveryStatus.BOUNCED,
                "unsubscribed": DeliveryStatus.UNSUBSCRIBED
            }
            
            if interaction_type in status_mapping:
                # Update execution status in database
                # execution.status = status_mapping[interaction_type]
                pass
            
            return True
            
        except Exception as e:
            logger.error(f"Error tracking campaign interaction: {e}")
            return False
    
    def get_campaign_analytics(self, campaign_id: str, date_range_days: int = 30) -> CampaignAnalytics:
        """Get comprehensive campaign performance analytics"""
        try:
            # This would query execution records and calculate metrics
            # For now, return mock analytics
            
            return CampaignAnalytics(
                campaign_id=campaign_id,
                total_sent=45,
                delivery_rate=0.98,
                open_rate=0.24,
                click_rate=0.08,
                response_rate=0.15,
                conversion_rate=0.12,
                unsubscribe_rate=0.002,
                revenue_generated=1850.0,
                campaign_cost=67.50,
                roi_percentage=2640.0,  # (1850 - 67.5) / 67.5 * 100
                best_performing_variant="variant_a",
                optimal_send_time=datetime.now().replace(hour=10, minute=0),
                audience_insights={
                    "most_responsive_segment": "high_value_clients",
                    "best_day_of_week": "Tuesday",
                    "preferred_channel": "email"
                },
                improvement_recommendations=[
                    "Increase email frequency for high-engagement clients",
                    "Test SMS campaigns for non-email responders",
                    "Personalize offers based on service preferences",
                    "Optimize send times for mobile-first audience"
                ]
            )
            
        except Exception as e:
            logger.error(f"Error getting campaign analytics: {e}")
            return None
    
    # Helper methods
    
    def _get_campaign_template(self, campaign_type: RetentionCampaignType, channel: CampaignChannel) -> CampaignTemplate:
        """Get appropriate template for campaign type and channel"""
        template_key = f"{campaign_type.value}_{channel.value}"
        return self.campaign_templates.get(template_key, self._get_default_template(channel))
    
    def _get_default_template(self, channel: CampaignChannel) -> CampaignTemplate:
        """Get default template for channel"""
        if channel == CampaignChannel.EMAIL:
            return CampaignTemplate(
                template_id="default_email",
                template_name="Default Email Template",
                channel=channel,
                campaign_type=RetentionCampaignType.PROACTIVE_OUTREACH,
                subject_template="We miss you, {first_name}! 💇‍♂️",
                message_template="Hi {first_name},\n\nIt's been {days_since_last_booking} days since your last appointment, and we wanted to check in! We value your business and would love to get you back in the chair.\n\n{special_offer}\n\nBook your next appointment today!\n\nBest regards,\nYour Six Figure Barber Team",
                personalization_level=CampaignPersonalization.ADVANCED,
                call_to_action="Book Now",
                urgency_level="medium",
                six_figure_messaging=True,
                a_b_variant=None,
                conversion_tracking_enabled=True
            )
        else:
            return CampaignTemplate(
                template_id="default_sms",
                template_name="Default SMS Template",
                channel=channel,
                campaign_type=RetentionCampaignType.PROACTIVE_OUTREACH,
                subject_template=None,
                message_template="Hi {first_name}! Missing you at the shop. Ready for your next fresh cut? {special_offer} Book: [LINK]",
                personalization_level=CampaignPersonalization.BASIC,
                call_to_action="Book Now",
                urgency_level="low",
                six_figure_messaging=True,
                a_b_variant=None,
                conversion_tracking_enabled=True
            )
    
    def _load_campaign_templates(self) -> Dict[str, CampaignTemplate]:
        """Load all campaign templates"""
        # This would load from database or configuration files
        # For now, return a basic set of templates
        
        templates = {}
        
        # Email templates
        templates["immediate_intervention_email"] = CampaignTemplate(
            template_id="immediate_intervention_email",
            template_name="Immediate Intervention Email",
            channel=CampaignChannel.EMAIL,
            campaign_type=RetentionCampaignType.IMMEDIATE_INTERVENTION,
            subject_template="🚨 {first_name}, we need to talk!",
            message_template="Hi {first_name},\n\nOur data shows you're at high risk of not returning ({churn_risk_score}% risk). As your barber, I care about maintaining our relationship.\n\n{special_offer}\n\nLet's get you back in the chair! Call me directly or book online.\n\n- Your Six Figure Barber",
            personalization_level=CampaignPersonalization.PREMIUM,
            call_to_action="Call Now",
            urgency_level="critical",
            six_figure_messaging=True,
            a_b_variant="urgent_tone",
            conversion_tracking_enabled=True
        )
        
        # SMS templates
        templates["immediate_intervention_sms"] = CampaignTemplate(
            template_id="immediate_intervention_sms",
            template_name="Immediate Intervention SMS",
            channel=CampaignChannel.SMS,
            campaign_type=RetentionCampaignType.IMMEDIATE_INTERVENTION,
            subject_template=None,
            message_template="{first_name}, I noticed you haven't booked in {days_since_last_booking} days. Let's get you fresh! {special_offer} Reply YES to book.",
            personalization_level=CampaignPersonalization.ADVANCED,
            call_to_action="Reply YES",
            urgency_level="high",
            six_figure_messaging=True,
            a_b_variant="casual_tone",
            conversion_tracking_enabled=True
        )
        
        return templates
    
    def _format_email_content(self, message: str) -> str:
        """Format message for email delivery with HTML"""
        html_content = f"""
        <html>
        <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <div style="background: linear-gradient(135deg, #1a1a1a 0%, #333333 100%); padding: 20px; text-align: center;">
                <h1 style="color: #FFD700; margin: 0;">Six Figure Barber</h1>
                <p style="color: white; margin: 5px 0;">Premium Barbering Experience</p>
            </div>
            
            <div style="padding: 30px; background: #f8f9fa; line-height: 1.6;">
                {message.replace('\n', '<br>')}
                
                <div style="margin-top: 30px; text-align: center;">
                    <a href="#" style="background: #FFD700; color: #1a1a1a; padding: 12px 30px; text-decoration: none; border-radius: 5px; font-weight: bold;">Book Appointment</a>
                </div>
            </div>
            
            <div style="padding: 20px; background: #1a1a1a; text-align: center;">
                <p style="color: #888; font-size: 12px; margin: 0;">
                    You're receiving this because you're a valued client. 
                    <a href="#" style="color: #FFD700;">Unsubscribe</a>
                </p>
            </div>
        </body>
        </html>
        """
        return html_content
    
    def _format_sms_content(self, message: str, client_name: str) -> str:
        """Format message for SMS delivery"""
        # SMS messages should be concise and include opt-out
        formatted_message = f"{message}\n\nReply STOP to opt out."
        
        # Ensure SMS is under 160 characters if possible
        if len(formatted_message) > 160:
            # Truncate if too long
            formatted_message = message[:140] + "... Reply STOP to opt out."
        
        return formatted_message
    
    def _calculate_delivery_cost(self, channel: CampaignChannel) -> float:
        """Calculate cost per campaign delivery"""
        costs = {
            CampaignChannel.EMAIL: 0.001,  # $0.001 per email
            CampaignChannel.SMS: 0.02,     # $0.02 per SMS  
            CampaignChannel.PUSH: 0.0001,  # $0.0001 per push
        }
        return costs.get(channel, 0.001)
    
    # Personalization helper methods
    
    def _get_client_favorite_service(self, client_id: int) -> str:
        """Get client's most frequently booked service"""
        try:
            # Query most common service for this client
            result = self.db.query(
                func.count(Appointment.service_id).label('count'),
                Appointment.service_id
            ).filter(
                Appointment.client_id == client_id
            ).group_by(
                Appointment.service_id
            ).order_by(desc('count')).first()
            
            if result:
                # Get service name (assuming Service model exists)
                # service = self.db.query(Service).filter(Service.id == result.service_id).first()
                # return service.name if service else "haircut"
                return "haircut"  # Fallback
            
            return "haircut"  # Default
            
        except Exception as e:
            logger.error(f"Error getting client favorite service: {e}")
            return "haircut"
    
    def _get_days_since_last_booking(self, client_id: int) -> int:
        """Get days since client's last booking"""
        try:
            last_appointment = self.db.query(Appointment).filter(
                Appointment.client_id == client_id
            ).order_by(desc(Appointment.appointment_date)).first()
            
            if last_appointment:
                return (datetime.now() - last_appointment.appointment_date).days
            
            return 365  # Default for new clients
            
        except Exception as e:
            logger.error(f"Error getting days since last booking: {e}")
            return 30  # Default
    
    def _get_preferred_appointment_time(self, client_id: int) -> str:
        """Get client's preferred appointment time"""
        try:
            appointments = self.db.query(Appointment).filter(
                Appointment.client_id == client_id
            ).all()
            
            if appointments:
                # Find most common hour
                hours = [apt.appointment_date.hour for apt in appointments]
                most_common_hour = max(set(hours), key=hours.count)
                
                if most_common_hour < 12:
                    return "morning"
                elif most_common_hour < 17:
                    return "afternoon"
                else:
                    return "evening"
            
            return "afternoon"  # Default
            
        except Exception as e:
            logger.error(f"Error getting preferred appointment time: {e}")
            return "afternoon"
    
    def _get_service_recommendations(self, client_id: int) -> str:
        """Get personalized service recommendations"""
        try:
            # This would analyze client history and suggest complementary services
            return "beard trim and hot towel treatment"
            
        except Exception as e:
            logger.error(f"Error getting service recommendations: {e}")
            return "premium grooming services"
    
    def _get_client_loyalty_tier(self, client_id: int) -> str:
        """Get client's loyalty tier"""
        try:
            # Calculate based on appointment frequency and spending
            appointment_count = self.db.query(Appointment).filter(
                Appointment.client_id == client_id
            ).count()
            
            if appointment_count >= 20:
                return "VIP"
            elif appointment_count >= 10:
                return "Premium"
            elif appointment_count >= 5:
                return "Regular"
            else:
                return "New"
                
        except Exception as e:
            logger.error(f"Error getting client loyalty tier: {e}")
            return "Valued"
    
    def _generate_personalized_offer(self, campaign: RetentionCampaign) -> str:
        """Generate personalized offer based on churn risk and value"""
        try:
            if campaign.churn_risk_score >= 80:
                return "Get 25% off your next appointment - we want you back!"
            elif campaign.churn_risk_score >= 60:
                return "Book now and receive a complimentary beard trim!"
            elif campaign.churn_risk_score >= 40:
                return "Special 15% discount for our loyal clients"
            else:
                return "Book your next appointment and earn double loyalty points!"
                
        except Exception as e:
            logger.error(f"Error generating personalized offer: {e}")
            return "Special offer available - book now!"
    
    def _generate_ai_custom_message(self, campaign: RetentionCampaign, client) -> str:
        """Generate AI-powered custom message (placeholder for now)"""
        try:
            # This would integrate with AI service for custom content generation
            return f"I've been thinking about you, {client.name}. Your last cut was amazing, and I have some new techniques I'd love to try on you!"
            
        except Exception as e:
            logger.error(f"Error generating AI custom message: {e}")
            return "Looking forward to your next visit!"
    
    def _get_six_figure_insight(self, client_id: int) -> str:
        """Get Six Figure methodology insight for client"""
        try:
            # This would provide Six Figure Barber coaching insights
            return "Pro tip: Regular clients who book every 3 weeks achieve the best style consistency!"
            
        except Exception as e:
            logger.error(f"Error getting Six Figure insight: {e}")
            return "Consistency is key to great style!"
    
    async def _schedule_campaign_delivery(self, execution: CampaignExecution) -> bool:
        """Schedule campaign for future delivery"""
        try:
            # This would integrate with a task queue like Celery
            # For now, just log the scheduling
            
            logger.info(f"Campaign {execution.execution_id} scheduled for {execution.scheduled_at}")
            return True
            
        except Exception as e:
            logger.error(f"Error scheduling campaign delivery: {e}")
            return False
    
    async def _process_campaign_batch(self, batch: CampaignBatch, executions: List[CampaignExecution]) -> bool:
        """Process campaign batch with rate limiting"""
        try:
            rate_limit = batch.delivery_rate_limit
            delay_between_sends = 60.0 / rate_limit  # Seconds between sends
            
            sent_count = 0
            failed_count = 0
            
            for execution in executions:
                # Send campaign
                success = await self._send_campaign_immediately(execution)
                
                if success:
                    sent_count += 1
                else:
                    failed_count += 1
                
                # Rate limiting delay
                await asyncio.sleep(delay_between_sends)
            
            # Update batch metrics
            batch.total_sent = sent_count
            batch.total_failed = failed_count
            batch.execution_status = "completed"
            
            logger.info(f"Batch {batch.batch_id} completed: {sent_count} sent, {failed_count} failed")
            return True
            
        except Exception as e:
            logger.error(f"Error processing campaign batch: {e}")
            batch.execution_status = "failed"
            return False