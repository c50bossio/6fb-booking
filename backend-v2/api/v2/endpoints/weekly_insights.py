"""
Weekly Insights API Endpoints for BookedBarber V2

This module provides comprehensive API endpoints for managing weekly business insights,
recommendations, and email delivery. It supports the Six Figure Barber methodology
with automated insights generation, personalized recommendations, and analytics tracking.

Endpoints:
- GET /weekly-insights - List weekly insights with pagination
- GET /weekly-insights/{insight_id} - Get specific insight details
- POST /weekly-insights/generate - Manually trigger insight generation
- GET /weekly-insights/history - Get insights history and trends
- GET /recommendations/{recommendation_id} - Get recommendation details
- PUT /recommendations/{recommendation_id}/status - Update recommendation status
- POST /recommendations/{recommendation_id}/feedback - Submit recommendation feedback
- GET /insights/analytics - Get insights system analytics
- POST /insights/email/send - Send insight email manually
- GET /insights/email/analytics - Get email delivery analytics
"""

from fastapi import APIRouter, Depends, HTTPException, Query, BackgroundTasks
from sqlalchemy.orm import Session
from typing import List, Optional, Any, Dict
from datetime import datetime, timedelta
from pydantic import BaseModel, Field, ConfigDict
import logging

from models import User
from models.weekly_insights import (
    WeeklyInsight, WeeklyRecommendation, InsightEmailDelivery,
    InsightCategory, RecommendationPriority, RecommendationStatus,
    InsightStatus, EmailDeliveryStatus
)
from services.weekly_insights_service import WeeklyInsightsService
from services.intelligent_recommendation_engine import IntelligentRecommendationEngine
from services.insight_email_service import InsightEmailService
from utils.auth import get_current_user
from utils.database import get_db

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/weekly-insights", tags=["Weekly Insights"])\n\n# Pydantic models for API requests/responses\n\nclass WeeklyInsightSummary(BaseModel):\n    """Summary model for weekly insight list responses"""\n    id: int\n    week_start_date: datetime\n    week_end_date: datetime\n    overall_score: float\n    score_change: Optional[float]\n    revenue_current_week: float\n    revenue_growth_percent: float\n    appointments_current_week: int\n    new_clients_count: int\n    status: str\n    generation_date: datetime\n    \n    model_config = ConfigDict(\n        from_attributes = True\n\nclass WeeklyInsightDetail(BaseModel):\n    """Detailed model for single insight responses"""\n    id: int\n    week_start_date: datetime\n    week_end_date: datetime\n    overall_score: float\n    previous_week_score: Optional[float]\n    score_change: Optional[float]\n    \n    # Business metrics\n    revenue_current_week: float\n    revenue_previous_week: float\n    revenue_growth_percent: float\n    appointments_current_week: int\n    appointments_previous_week: int\n    appointment_growth_percent: float\n    new_clients_count: int\n    returning_clients_count: int\n    client_retention_rate: float\n    average_ticket_size: float\n    booking_efficiency_percent: float\n    no_show_rate_percent: float\n    \n    # Six Figure Barber scores\n    revenue_optimization_score: float\n    client_value_score: float\n    service_excellence_score: float\n    business_efficiency_score: float\n    professional_growth_score: float\n    \n    # Insights\n    trend_analysis: Optional[Dict[str, Any]]\n    top_achievements: Optional[List[str]]\n    key_opportunities: Optional[List[str]]\n    risk_factors: Optional[List[str]]\n    executive_summary: Optional[str]\n    key_insights: Optional[str]\n    \n    status: str\n    generation_date: datetime\n    generation_duration_seconds: Optional[float]\n    \n    model_config = ConfigDict(\n        from_attributes = True\n\nclass RecommendationResponse(BaseModel):\n    """Model for recommendation responses"""\n    id: int\n    category: str\n    priority: str\n    title: str\n    description: str\n    expected_impact: Optional[str]\n    estimated_effort: Optional[str]\n    confidence_score: float\n    six_fb_principle: Optional[str]\n    methodology_alignment_score: float\n    action_items: Optional[List[str]]\n    success_metrics: Optional[List[str]]\n    status: str\n    user_feedback_rating: Optional[int]\n    user_feedback_text: Optional[str]\n    created_at: datetime\n    \n    model_config = ConfigDict(\n        from_attributes = True\n\nclass RecommendationStatusUpdate(BaseModel):\n    """Model for updating recommendation status"""\n    status: RecommendationStatus\n    feedback: Optional[str] = None\n    implementation_notes: Optional[str] = None\n\nclass RecommendationFeedback(BaseModel):\n    """Model for recommendation feedback"""\n    rating: int = Field(..., ge=1, le=5, description="Rating from 1-5 stars")\n    feedback_text: Optional[str] = None\n    implemented: bool = False\n    measured_impact: Optional[str] = None\n    roi_actual: Optional[float] = None\n\nclass InsightGenerationRequest(BaseModel):\n    """Model for manual insight generation requests"""\n    week_start_date: Optional[datetime] = None\n    force_regenerate: bool = False\n\nclass EmailSendRequest(BaseModel):\n    """Model for manual email send requests"""\n    insight_id: int\n    template_name: Optional[str] = None\n    scheduled_time: Optional[datetime] = None\n\nclass InsightTrendResponse(BaseModel):\n    """Model for insight trend responses"""\n    metric_name: str\n    data_points: List[Dict[str, Any]]\n    trend_direction: str\n    correlation_score: float\n\n# API Endpoints\n\n@router.get("", response_model=List[WeeklyInsightSummary])\nasync def list_weekly_insights(\n    skip: int = Query(0, ge=0, description="Number of records to skip"),\n    limit: int = Query(20, ge=1, le=100, description="Number of records to return"),\n    status: Optional[str] = Query(None, description="Filter by insight status"),\n    weeks_back: Optional[int] = Query(12, ge=1, le=52, description="How many weeks back to retrieve"),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Get list of weekly insights for the authenticated user\n    \n    Returns paginated list of weekly insights with summary information.\n    Supports filtering by status and time range.\n    """\n    try:\n        service = WeeklyInsightsService(db)\n        \n        # Get base query\n        cutoff_date = datetime.now() - timedelta(weeks=weeks_back)\n        \n        query = db.query(WeeklyInsight).filter(\n            WeeklyInsight.user_id == current_user.id,\n            WeeklyInsight.week_start_date >= cutoff_date\n        )\n        \n        # Apply status filter if provided\n        if status:\n            try:\n                status_enum = InsightStatus(status)\n                query = query.filter(WeeklyInsight.status == status_enum)\n            except ValueError:\n                raise HTTPException(status_code=400, detail=f"Invalid status: {status}")\n        \n        # Apply pagination and ordering\n        insights = query.order_by(\n            WeeklyInsight.week_start_date.desc()\n        ).offset(skip).limit(limit).all()\n        \n        return insights\n        \n    except Exception as e:\n        logger.error(f"Error listing weekly insights for user {current_user.id}: {e}")\n        raise HTTPException(status_code=500, detail="Failed to retrieve weekly insights")\n\n@router.get("/{insight_id}", response_model=WeeklyInsightDetail)\nasync def get_weekly_insight(\n    insight_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Get detailed information about a specific weekly insight\n    \n    Returns comprehensive insight data including all metrics, recommendations,\n    and analysis results.\n    """\n    try:\n        insight = db.query(WeeklyInsight).filter(\n            WeeklyInsight.id == insight_id,\n            WeeklyInsight.user_id == current_user.id\n        ).first()\n        \n        if not insight:\n            raise HTTPException(status_code=404, detail="Weekly insight not found")\n        \n        return insight\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f"Error retrieving weekly insight {insight_id}: {e}")\n        raise HTTPException(status_code=500, detail="Failed to retrieve weekly insight")\n\n@router.post("/generate")\nasync def generate_weekly_insight(\n    request: InsightGenerationRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Manually trigger weekly insight generation\n    \n    Generates insights for the specified week or current week if not specified.\n    Process runs in background and returns immediately with generation status.\n    """\n    try:\n        service = WeeklyInsightsService(db)\n        \n        # Check if insights already exist for the requested week\n        week_start = request.week_start_date\n        if not week_start:\n            today = datetime.now()\n            days_since_monday = today.weekday()\n            week_start = today - timedelta(days=days_since_monday, weeks=1)\n            week_start = week_start.replace(hour=0, minute=0, second=0, microsecond=0)\n        \n        existing_insight = db.query(WeeklyInsight).filter(\n            WeeklyInsight.user_id == current_user.id,\n            WeeklyInsight.week_start_date == week_start\n        ).first()\n        \n        if existing_insight and not request.force_regenerate:\n            if existing_insight.status == InsightStatus.GENERATED:\n                return {\n                    "message": "Insights already exist for this week",\n                    "insight_id": existing_insight.id,\n                    "status": "already_exists"\n                }\n            elif existing_insight.status == InsightStatus.GENERATING:\n                return {\n                    "message": "Insights are currently being generated",\n                    "insight_id": existing_insight.id,\n                    "status": "in_progress"\n                }\n        \n        # Queue insight generation in background\n        background_tasks.add_task(\n            _generate_insight_background,\n            db_session=db,\n            user_id=current_user.id,\n            week_start=week_start\n        )\n        \n        return {\n            "message": "Weekly insight generation started",\n            "week_start": week_start.isoformat(),\n            "status": "queued"\n        }\n        \n    except Exception as e:\n        logger.error(f"Error starting insight generation for user {current_user.id}: {e}")\n        raise HTTPException(status_code=500, detail="Failed to start insight generation")\n\n@router.get("/history/trends")\nasync def get_insight_trends(\n    metric_name: str = Query(..., description="Metric name to get trends for"),\n    weeks_back: int = Query(12, ge=4, le=52, description="Number of weeks to analyze"),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Get historical trends for a specific metric\n    \n    Returns trend data over time for metrics like overall_score,\n    revenue_current_week, booking_efficiency_percent, etc.\n    """\n    try:\n        service = WeeklyInsightsService(db)\n        trends = service.get_insight_trends(current_user.id, metric_name, weeks_back)\n        \n        if not trends:\n            raise HTTPException(status_code=404, detail=f"No trend data found for metric: {metric_name}")\n        \n        # Calculate trend direction\n        if len(trends) >= 2:\n            recent_avg = sum(d['value'] for d in trends[-4:]) / min(4, len(trends))\n            older_avg = sum(d['value'] for d in trends[:4]) / min(4, len(trends))\n            \n            if recent_avg > older_avg * 1.05:\n                trend_direction = "improving"\n            elif recent_avg < older_avg * 0.95:\n                trend_direction = "declining"\n            else:\n                trend_direction = "stable"\n        else:\n            trend_direction = "insufficient_data"\n        \n        return {\n            "metric_name": metric_name,\n            "data_points": trends,\n            "trend_direction": trend_direction,\n            "weeks_analyzed": len(trends)\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f"Error retrieving trends for {metric_name}: {e}")\n        raise HTTPException(status_code=500, detail="Failed to retrieve trend data")\n\n@router.get("/{insight_id}/recommendations", response_model=List[RecommendationResponse])\nasync def get_insight_recommendations(\n    insight_id: int,\n    category: Optional[str] = Query(None, description="Filter by recommendation category"),\n    priority: Optional[str] = Query(None, description="Filter by recommendation priority"),\n    status: Optional[str] = Query(None, description="Filter by recommendation status"),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Get recommendations for a specific weekly insight\n    \n    Returns all recommendations associated with the insight,\n    with optional filtering by category, priority, or status.\n    """\n    try:\n        # Verify insight belongs to user\n        insight = db.query(WeeklyInsight).filter(\n            WeeklyInsight.id == insight_id,\n            WeeklyInsight.user_id == current_user.id\n        ).first()\n        \n        if not insight:\n            raise HTTPException(status_code=404, detail="Weekly insight not found")\n        \n        # Build query for recommendations\n        query = db.query(WeeklyRecommendation).filter(\n            WeeklyRecommendation.weekly_insight_id == insight_id\n        )\n        \n        # Apply filters\n        if category:\n            try:\n                category_enum = InsightCategory(category)\n                query = query.filter(WeeklyRecommendation.category == category_enum)\n            except ValueError:\n                raise HTTPException(status_code=400, detail=f"Invalid category: {category}")\n        \n        if priority:\n            try:\n                priority_enum = RecommendationPriority(priority)\n                query = query.filter(WeeklyRecommendation.priority == priority_enum)\n            except ValueError:\n                raise HTTPException(status_code=400, detail=f"Invalid priority: {priority}")\n        \n        if status:\n            try:\n                status_enum = RecommendationStatus(status)\n                query = query.filter(WeeklyRecommendation.status == status_enum)\n            except ValueError:\n                raise HTTPException(status_code=400, detail=f"Invalid status: {status}")\n        \n        # Get recommendations ordered by priority and confidence\n        recommendations = query.order_by(\n            WeeklyRecommendation.priority.desc(),\n            WeeklyRecommendation.confidence_score.desc()\n        ).all()\n        \n        return recommendations\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f"Error retrieving recommendations for insight {insight_id}: {e}")\n        raise HTTPException(status_code=500, detail="Failed to retrieve recommendations")\n\n@router.get("/recommendations/{recommendation_id}", response_model=RecommendationResponse)\nasync def get_recommendation(\n    recommendation_id: int,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Get detailed information about a specific recommendation\n    """\n    try:\n        recommendation = db.query(WeeklyRecommendation).filter(\n            WeeklyRecommendation.id == recommendation_id,\n            WeeklyRecommendation.user_id == current_user.id\n        ).first()\n        \n        if not recommendation:\n            raise HTTPException(status_code=404, detail="Recommendation not found")\n        \n        return recommendation\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f"Error retrieving recommendation {recommendation_id}: {e}")\n        raise HTTPException(status_code=500, detail="Failed to retrieve recommendation")\n\n@router.put("/recommendations/{recommendation_id}/status")\nasync def update_recommendation_status(\n    recommendation_id: int,\n    update_request: RecommendationStatusUpdate,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Update the status of a recommendation\n    \n    Allows barbers to track their progress on implementing recommendations\n    and provide feedback on the process.\n    """\n    try:\n        service = WeeklyInsightsService(db)\n        \n        # Verify recommendation belongs to user\n        recommendation = db.query(WeeklyRecommendation).filter(\n            WeeklyRecommendation.id == recommendation_id,\n            WeeklyRecommendation.user_id == current_user.id\n        ).first()\n        \n        if not recommendation:\n            raise HTTPException(status_code=404, detail="Recommendation not found")\n        \n        # Update status\n        success = service.update_recommendation_status(\n            recommendation_id=recommendation_id,\n            status=update_request.status.value,\n            user_feedback=update_request.feedback\n        )\n        \n        if not success:\n            raise HTTPException(status_code=500, detail="Failed to update recommendation status")\n        \n        # Update additional fields if provided\n        if update_request.implementation_notes:\n            recommendation.implementation_notes = update_request.implementation_notes\n            db.commit()\n        \n        return {\n            "message": "Recommendation status updated successfully",\n            "recommendation_id": recommendation_id,\n            "new_status": update_request.status.value\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f"Error updating recommendation status: {e}")\n        raise HTTPException(status_code=500, detail="Failed to update recommendation status")\n\n@router.post("/recommendations/{recommendation_id}/feedback")\nasync def submit_recommendation_feedback(\n    recommendation_id: int,\n    feedback: RecommendationFeedback,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Submit detailed feedback on a recommendation\n    \n    Allows barbers to rate recommendations and provide detailed feedback\n    on implementation results and measured impact.\n    """\n    try:\n        recommendation = db.query(WeeklyRecommendation).filter(\n            WeeklyRecommendation.id == recommendation_id,\n            WeeklyRecommendation.user_id == current_user.id\n        ).first()\n        \n        if not recommendation:\n            raise HTTPException(status_code=404, detail="Recommendation not found")\n        \n        # Update feedback fields\n        recommendation.user_feedback_rating = feedback.rating\n        recommendation.user_feedback_text = feedback.feedback_text\n        recommendation.measured_impact = feedback.measured_impact\n        recommendation.roi_actual = feedback.roi_actual\n        \n        if feedback.implemented:\n            recommendation.status = RecommendationStatus.COMPLETED\n            recommendation.implemented_date = datetime.utcnow()\n        \n        db.commit()\n        \n        # Track effectiveness for recommendation engine improvement\n        if feedback.roi_actual is not None:\n            engine = IntelligentRecommendationEngine(db)\n            engine.track_recommendation_effectiveness(\n                recommendation_id=recommendation_id,\n                outcome_data={\n                    "success_achieved": feedback.implemented,\n                    "measured_impact": feedback.measured_impact,\n                    "roi_actual": feedback.roi_actual,\n                    "roi_estimated": recommendation.confidence_score * 20  # Estimate\n                }\n            )\n        \n        return {\n            "message": "Feedback submitted successfully",\n            "recommendation_id": recommendation_id\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f"Error submitting recommendation feedback: {e}")\n        raise HTTPException(status_code=500, detail="Failed to submit feedback")\n\n@router.get("/analytics/system")\nasync def get_insights_system_analytics(\n    days_back: int = Query(30, ge=7, le=90, description="Days of analytics to retrieve"),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Get analytics about the insights system performance\n    \n    Returns metrics about insight generation, recommendation effectiveness,\n    and user engagement with the insights system.\n    """\n    try:\n        cutoff_date = datetime.utcnow() - timedelta(days=days_back)\n        \n        # Insight generation analytics\n        insights_count = db.query(WeeklyInsight).filter(\n            WeeklyInsight.user_id == current_user.id,\n            WeeklyInsight.created_at >= cutoff_date\n        ).count()\n        \n        successful_insights = db.query(WeeklyInsight).filter(\n            WeeklyInsight.user_id == current_user.id,\n            WeeklyInsight.created_at >= cutoff_date,\n            WeeklyInsight.status == InsightStatus.GENERATED\n        ).count()\n        \n        # Recommendation analytics\n        recommendations = db.query(WeeklyRecommendation).filter(\n            WeeklyRecommendation.user_id == current_user.id,\n            WeeklyRecommendation.created_at >= cutoff_date\n        ).all()\n        \n        implemented_recs = [r for r in recommendations if r.status == RecommendationStatus.COMPLETED]\n        rated_recs = [r for r in recommendations if r.user_feedback_rating is not None]\n        \n        avg_rating = sum(r.user_feedback_rating for r in rated_recs) / len(rated_recs) if rated_recs else 0\n        \n        # Email analytics\n        email_service = InsightEmailService(db)\n        email_analytics = email_service.get_email_analytics(current_user.id, days_back)\n        \n        return {\n            "period_days": days_back,\n            "insights_generated": insights_count,\n            "generation_success_rate": (successful_insights / insights_count * 100) if insights_count > 0 else 0,\n            "total_recommendations": len(recommendations),\n            "implemented_recommendations": len(implemented_recs),\n            "implementation_rate": (len(implemented_recs) / len(recommendations) * 100) if recommendations else 0,\n            "average_recommendation_rating": round(avg_rating, 2),\n            "email_analytics": email_analytics\n        }\n        \n    except Exception as e:\n        logger.error(f"Error retrieving insights system analytics: {e}")\n        raise HTTPException(status_code=500, detail="Failed to retrieve system analytics")\n\n@router.post("/email/send")\nasync def send_insight_email(\n    request: EmailSendRequest,\n    background_tasks: BackgroundTasks,\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Manually send a weekly insight email\n    \n    Sends the insight email immediately or schedules it for future delivery.\n    """\n    try:\n        # Verify insight belongs to user\n        insight = db.query(WeeklyInsight).filter(\n            WeeklyInsight.id == request.insight_id,\n            WeeklyInsight.user_id == current_user.id\n        ).first()\n        \n        if not insight:\n            raise HTTPException(status_code=404, detail="Weekly insight not found")\n        \n        if insight.status != InsightStatus.GENERATED:\n            raise HTTPException(status_code=400, detail="Insight must be generated before sending email")\n        \n        # Queue email sending in background\n        background_tasks.add_task(\n            _send_email_background,\n            db_session=db,\n            insight_id=request.insight_id,\n            template_name=request.template_name,\n            scheduled_time=request.scheduled_time\n        )\n        \n        return {\n            "message": "Email send queued successfully",\n            "insight_id": request.insight_id,\n            "scheduled_time": request.scheduled_time.isoformat() if request.scheduled_time else "immediate"\n        }\n        \n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f"Error queuing insight email: {e}")\n        raise HTTPException(status_code=500, detail="Failed to queue email send")\n\n@router.get("/email/analytics")\nasync def get_email_analytics(\n    days_back: int = Query(30, ge=7, le=90, description="Days of analytics to retrieve"),\n    db: Session = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    """\n    Get email delivery and engagement analytics\n    \n    Returns comprehensive metrics about email delivery, open rates,\n    click rates, and user engagement patterns.\n    """\n    try:\n        email_service = InsightEmailService(db)\n        analytics = email_service.get_email_analytics(current_user.id, days_back)\n        \n        return {\n            "period_days": days_back,\n            **analytics\n        }\n        \n    except Exception as e:\n        logger.error(f"Error retrieving email analytics: {e}")\n        raise HTTPException(status_code=500, detail="Failed to retrieve email analytics")\n\n# Background task functions\n\nasync def _generate_insight_background(db_session: Session, user_id: int, week_start: datetime):\n    """Background task for generating weekly insights"""\n    try:\n        service = WeeklyInsightsService(db_session)\n        insight = service.generate_weekly_insights(user_id, week_start)\n        logger.info(f"Successfully generated insight {insight.id} for user {user_id}")\n    except Exception as e:\n        logger.error(f"Background insight generation failed for user {user_id}: {e}")\n\nasync def _send_email_background(db_session: Session, insight_id: int, \n                                template_name: Optional[str], scheduled_time: Optional[datetime]):\n    """Background task for sending insight emails"""\n    try:\n        email_service = InsightEmailService(db_session)\n        delivery = email_service.send_weekly_insight_email(\n            insight_id=insight_id,\n            template_name=template_name,\n            scheduled_time=scheduled_time\n        )\n        logger.info(f"Successfully queued email delivery {delivery.id} for insight {insight_id}")\n    except Exception as e:\n        logger.error(f"Background email send failed for insight {insight_id}: {e}")